name: MLOps CI/CD Pipeline

# This workflow runs on any push to the 'main' branch
on:
  push:
    branches: [ main ]

jobs:
  #################################################################
  # JOB 1: Build, Scan, and Push the Docker Image
  #################################################################
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker Hub
        # This action uses the secrets we created in the repository settings.
        # It securely logs in so we can push our image.
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        # This is the core build step. It builds the Dockerfile located in src/app
        # and pushes it to our Docker Hub repository. We tag it with 'latest' and
        # a unique Git SHA for versioning.
        uses: docker/build-push-action@v4
        with:
          context: ./src/app
          file: ./src/app/Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/model-server:latest, ${{ secrets.DOCKERHUB_USERNAME }}/model-server:${{ github.sha }}
      
      # NOTE: In a real-world scenario, a vulnerability scan (e.g., Snyk, Trivy)
      # would be added here to check the built image before pushing.

  #################################################################
  # JOB 2: Lint and Validate the Helm Chart
  #################################################################
  lint-and-validate:
    name: Lint and Validate Helm Chart
    runs-on: ubuntu-latest
    # This job can run in parallel with the build job to save time.
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Helm
        # This action installs the Helm CLI in our runner.
        uses: azure/setup-helm@v3
        with:
          version: v3.8.1

      - name: Lint Helm chart
        # 'helm lint' is a critical static analysis step. It checks our chart for
        # formatting errors and ensures it follows best practices. This catches
        # errors before we ever attempt to deploy.
        run: helm lint ./helm/model-server

  #################################################################
  # JOB 3: Deploy to Staging (Simulated)
  #################################################################
  deploy-to-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    # This job runs ONLY after the build and linting jobs have succeeded.
    needs: [build-and-push, lint-and-validate]
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Simulate Deployment to Staging
        # In a real pipeline, this is where we would have steps to authenticate
        # with a cloud provider (AWS, GCP) and use 'helm upgrade --install'.
        # For this demo, we explain the command, which is safer and clearer.
        run: |
          echo "Simulating deployment to Staging Kubernetes Cluster..."
          echo "COMMAND THAT WOULD RUN:"
          echo "helm upgrade --install model-server-staging ./helm/model-server --set image.tag=${{ github.sha }} --namespace staging"
          echo "Deployment to staging simulated successfully."

  #################################################################
  # JOB 4: Deploy to Production (Simulated)
  #################################################################
  deploy-to-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-to-staging # This job runs only after staging deployment is successful.
    if: github.ref == 'refs/heads/main' # Gatekeeper: Only run for pushes to the 'main' branch.
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
            
      - name: Simulate Deployment to Production
        # The production deploy would be identical to staging but would target the
        # production cluster and namespace, likely requiring a manual approval gate.
        run: |
          echo "Simulating deployment to Production Kubernetes Cluster..."
          echo "COMMAND THAT WOULD RUN:"
          echo "helm upgrade --install model-server-prod ./helm/model-server --set image.tag=${{ github.sha }} --namespace production"
          echo "Deployment to production simulated successfully."
